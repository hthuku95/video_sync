// LangGraph-inspired state management for video editing workflows
// Replaces hardcoded iteration limits with flexible graph-based execution

use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use chrono::{DateTime, Utc};

/// Workflow state that persists across agent interactions
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VideoWorkflowState {
    /// Unique workflow session ID
    pub session_id: String,

    /// Current step in the workflow
    pub current_step: String,

    /// User's original request
    pub user_request: String,

    /// Conversation history (condensed)
    pub conversation_history: Vec<ConversationTurn>,

    /// Files in this session
    pub input_files: Vec<FileReference>,

    /// Intermediate and final outputs
    pub output_files: Vec<FileReference>,

    /// Execution plan (generated by AI)
    pub execution_plan: Option<ExecutionPlan>,

    /// Current execution state
    pub execution_state: ExecutionState,

    /// Tool execution results
    pub tool_results: HashMap<String, ToolResult>,

    /// Errors encountered
    pub errors: Vec<WorkflowError>,

    /// Metadata
    pub metadata: HashMap<String, serde_json::Value>,

    /// Timestamps
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConversationTurn {
    pub role: String, // "user" or "assistant"
    pub content: String,
    pub timestamp: DateTime<Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileReference {
    pub file_id: String,
    pub file_path: String,
    pub file_type: String, // "input" or "output" or "intermediate"
    pub metadata: HashMap<String, serde_json::Value>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExecutionPlan {
    /// Steps in the execution plan
    pub steps: Vec<PlanStep>,

    /// Current step index
    pub current_step_index: usize,

    /// Total steps
    pub total_steps: usize,

    /// Can execute steps in parallel
    pub parallel_groups: Vec<Vec<usize>>, // indices of steps that can run in parallel
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PlanStep {
    pub step_id: String,
    pub tool_name: String,
    pub description: String,
    pub inputs: HashMap<String, serde_json::Value>,
    pub depends_on: Vec<String>, // step_ids this step depends on
    pub status: StepStatus,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum StepStatus {
    Pending,
    Running,
    Completed,
    Failed,
    Skipped,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ExecutionState {
    /// Initial planning phase
    Planning,

    /// Executing tools
    Executing,

    /// Waiting for user input/clarification
    WaitingForInput,

    /// All steps completed successfully
    Completed,

    /// Failed with errors
    Failed,

    /// Paused by user
    Paused,

    /// Cancelled by user
    Cancelled,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ToolResult {
    pub tool_name: String,
    pub success: bool,
    pub output: String,
    pub output_files: Vec<String>,
    pub execution_time_ms: u64,
    pub timestamp: DateTime<Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WorkflowError {
    pub error_type: String,
    pub message: String,
    pub step_id: Option<String>,
    pub recoverable: bool,
    pub timestamp: DateTime<Utc>,
}

impl VideoWorkflowState {
    pub fn new(session_id: String, user_request: String) -> Self {
        Self {
            session_id,
            current_step: "initial".to_string(),
            user_request,
            conversation_history: Vec::new(),
            input_files: Vec::new(),
            output_files: Vec::new(),
            execution_plan: None,
            execution_state: ExecutionState::Planning,
            tool_results: HashMap::new(),
            errors: Vec::new(),
            metadata: HashMap::new(),
            created_at: Utc::now(),
            updated_at: Utc::now(),
        }
    }

    pub fn add_conversation_turn(&mut self, role: &str, content: &str) {
        self.conversation_history.push(ConversationTurn {
            role: role.to_string(),
            content: content.to_string(),
            timestamp: Utc::now(),
        });
        self.updated_at = Utc::now();
    }

    pub fn add_input_file(&mut self, file_path: &str, metadata: HashMap<String, serde_json::Value>) {
        self.input_files.push(FileReference {
            file_id: uuid::Uuid::new_v4().to_string(),
            file_path: file_path.to_string(),
            file_type: "input".to_string(),
            metadata,
        });
        self.updated_at = Utc::now();
    }

    pub fn add_output_file(&mut self, file_path: &str, metadata: HashMap<String, serde_json::Value>) {
        self.output_files.push(FileReference {
            file_id: uuid::Uuid::new_v4().to_string(),
            file_path: file_path.to_string(),
            file_type: "output".to_string(),
            metadata,
        });
        self.updated_at = Utc::now();
    }

    pub fn set_execution_plan(&mut self, plan: ExecutionPlan) {
        self.execution_plan = Some(plan);
        self.execution_state = ExecutionState::Executing;
        self.updated_at = Utc::now();
    }

    pub fn record_tool_result(&mut self, step_id: &str, result: ToolResult) {
        self.tool_results.insert(step_id.to_string(), result);
        self.updated_at = Utc::now();
    }

    pub fn add_error(&mut self, error: WorkflowError) {
        self.errors.push(error);
        self.updated_at = Utc::now();
    }

    pub fn is_completed(&self) -> bool {
        self.execution_state == ExecutionState::Completed
    }

    pub fn is_failed(&self) -> bool {
        self.execution_state == ExecutionState::Failed
    }

    pub fn can_execute_parallel(&self) -> Vec<Vec<PlanStep>> {
        if let Some(plan) = &self.execution_plan {
            let mut parallel_groups = Vec::new();

            for group_indices in &plan.parallel_groups {
                let steps: Vec<PlanStep> = group_indices.iter()
                    .filter_map(|&idx| plan.steps.get(idx).cloned())
                    .filter(|step| step.status == StepStatus::Pending)
                    .collect();

                if !steps.is_empty() {
                    parallel_groups.push(steps);
                }
            }

            parallel_groups
        } else {
            Vec::new()
        }
    }

    pub fn get_next_step(&self) -> Option<PlanStep> {
        if let Some(plan) = &self.execution_plan {
            plan.steps.iter()
                .find(|step| step.status == StepStatus::Pending)
                .cloned()
        } else {
            None
        }
    }

    pub fn mark_step_completed(&mut self, step_id: &str) {
        if let Some(plan) = &mut self.execution_plan {
            if let Some(step) = plan.steps.iter_mut().find(|s| s.step_id == step_id) {
                step.status = StepStatus::Completed;
                plan.current_step_index += 1;
            }
        }
        self.updated_at = Utc::now();
    }

    pub fn mark_step_failed(&mut self, step_id: &str) {
        if let Some(plan) = &mut self.execution_plan {
            if let Some(step) = plan.steps.iter_mut().find(|s| s.step_id == step_id) {
                step.status = StepStatus::Failed;
            }
        }
        self.execution_state = ExecutionState::Failed;
        self.updated_at = Utc::now();
    }

    /// Check if all steps are completed
    pub fn all_steps_completed(&self) -> bool {
        if let Some(plan) = &self.execution_plan {
            plan.steps.iter().all(|step| {
                step.status == StepStatus::Completed || step.status == StepStatus::Skipped
            })
        } else {
            false
        }
    }

    /// Get progress percentage
    pub fn progress_percentage(&self) -> f32 {
        if let Some(plan) = &self.execution_plan {
            let completed = plan.steps.iter()
                .filter(|s| s.status == StepStatus::Completed || s.status == StepStatus::Skipped)
                .count();
            (completed as f32 / plan.total_steps as f32) * 100.0
        } else {
            0.0
        }
    }
}

/// Workflow state manager with persistence
pub struct VideoWorkflowManager {
    // In-memory cache of active workflows
    workflows: std::sync::Arc<tokio::sync::RwLock<HashMap<String, VideoWorkflowState>>>,
}

impl VideoWorkflowManager {
    pub fn new() -> Self {
        Self {
            workflows: std::sync::Arc::new(tokio::sync::RwLock::new(HashMap::new())),
        }
    }

    pub async fn create_workflow(&self, session_id: String, user_request: String) -> VideoWorkflowState {
        let state = VideoWorkflowState::new(session_id.clone(), user_request);
        let mut workflows = self.workflows.write().await;
        workflows.insert(session_id, state.clone());
        state
    }

    pub async fn get_workflow(&self, session_id: &str) -> Option<VideoWorkflowState> {
        let workflows = self.workflows.read().await;
        workflows.get(session_id).cloned()
    }

    pub async fn update_workflow(&self, state: VideoWorkflowState) {
        let mut workflows = self.workflows.write().await;
        workflows.insert(state.session_id.clone(), state);
    }

    pub async fn delete_workflow(&self, session_id: &str) {
        let mut workflows = self.workflows.write().await;
        workflows.remove(session_id);
    }

    pub async fn get_active_workflows(&self) -> Vec<VideoWorkflowState> {
        let workflows = self.workflows.read().await;
        workflows.values().cloned().collect()
    }
}
